##  基本存储管理

###  一、内存管理的主要功能

#### 1.内存的分配与回收

> 实现目标：合理分配、回收

##### 1.1 合理分配

##### 1.2 及时回收

#### 2.地址重定位

>  将逻辑地址转换未物理地址

物理地址：存储单元的实际物理单元地址。

逻辑地址：用户空间中使用的相对地址。

#####  2.1静态重定位

> * 地址转换工作在进程执行前一次完成。
>
> * 无需硬件支持，易于实现，但不允许程序在执行过程中移动

##### 2.2动态重定位

> * 地址转换推出到最后的可能时刻，即进程执行时才完成
> * 允许程序在主存中移动，便于主存共存，主存利用率高

#### 3.地址共享和保护

##### 3.1共享

> * 允许多个进程同时进入内存区域，共享一个存储器。
> * 共享内存储器的某些区域，即允许两个或多个进行访问内存中的同一段程序或数据。

##### 3.2地址保护

> * 用户进程不能访问和修改系统区
> * 用户进程不能访问或修改其他进程的用户区

##### 3.3地址保护方法

__存储键保护__

> * 系统将主存划分成大小相同的若干存储块，给每个存储块都分配一个单独的保护键（锁）
> * 在程序状态字PSW中设置有保护键字段，对不同的作业赋予不同的代码（钥匙）；钥匙和锁相配才允许访问。

__界限寄存器__

> * 上、下界防护：硬件为分给用户作业的连续的主存空间设置一对上、下界，分别指向该存储空间的上、下界
> * 基址、限长防护：基址寄存器存放当前正在执行者的程序地址空间所占分区的始址，限长寄存器存放该地址空间的长度

#### 4.地址扩充

通过软件的方法，进行逻辑扩充

* 覆盖技术

* 对换技术

* 虚拟存储技术

  

###  二、地址管理方法

> 记录内存使用情况的数据结构有：
>
> MAT（主存分配表）
>
> 空闲分区表/链

#### 1.连续存储管理 

> 实质特点：一个进程装入连续的一块内存空间

> 

#####  1.1单一连续区方式

> 内存用户区的全部空间只存放一个进程

##### 1.2多分区方法

> 内存被分为多个分区，每个分区存放一个进程

* 固定多分区

  > * 将内存用户区划分成多个大小相等或不等的固定分区，每个分区可以装入一个进程。
  >
  > * MAT表可以用静态数组实现，因为分区数量固定
  >
  > * 大的进程可能无法装入
  >
  > * 小的进程装入大分区出现`内部碎片`
  >
  > * 可以采用最佳适应算法``Best_Fit`可以减少`内部碎片`
  >
  > * 因为固定分区，程序不发生迁移，所以采用`静态重定位`。

* 动态多分区

  > * 内存预先不分区，在装入进程时，根据内存的实际需求划分一个分区使用
  >
  > * MAT表需要使用动态数组实现，因为分区数量不固定
  >
  > * 因为多次划分，可能形成零零星星并且因为太小不容易被分配的空闲区，也就是`外部碎片`
  >
  > * 采用最坏适应算法`Worst_Fit`可以减少`外碎片`
  >
  > * 在`主存分配`过程中，通过程序浮动将不相邻的空闲分区移为相邻的进行合并。以消除`外部碎片`
  >
  > * 在`分区回收`过程中，将相邻的空闲分区进行合并。以消除`外部碎片`
  >
  > * 因为动态多分区会有程序浮动，将程序移动，所以需要用`动态重定位`

#####  1.3 主存分配算法

* 首次适应算法 `First_Fit`：从头到尾在内存分配表（或空闲分区表）中找到第一块满足要求的空闲分区。
* 循环首次适应算法`Circle_First_Fit`：从上一次分配的位置开始进行查找。
* 最佳适应算法`Best_Fit`：找到空闲分区表中满足需求的最小空闲分区进行分配。
* 最坏适应算法`Worst_Fit`：找到空闲分区表中最大一个块进行分配。

#### 2.非连续存储管理

> 一个进程分为多个单位，以离散的方式装入内存。

##### 2.1分页方式

> 内存被划分为多个等长的`存储块（Frame帧、页框、主存块）` ，每个进程占用其中的若干块，整个内存允许有多个进程同时驻留。
>
> 每个进程进行装入时，被分成同样大小的`页(Page)`，一`页`装入一`帧`。
>
> 整个进程被离散的装入不同的`帧`
>
> * 页的长度
>
>   页面的尺寸由计算机系统的硬件决定
>
>   目前流行的页面尺寸多在1KB到4KB之间
>
>   例：
>
>   ```txt
>   若机器的地址码是16位，页面长度是1KB
>   则地址划分结果位：低10位是页内地址，高6位是页号。
>   这样的地址结构，允许一个进程的页面总数位64页（2的6次方）。
>   ```
>
> * 位示图
>
>   整个系统一张图，记录内存使用情况，它只记录帧的占用和空闲。
>
>   帧号`k`=(字号)`i`*(位号)`L`+(字长)`j`
>
> * 页表PT（Page Table）
>
>   每个进程由一张PT，记录本进程分页以及占用帧的情况。
>
>   将PT的起始地址填入进程的`PCB`中
>
> 分页利于大进程装入，内存利用率高。
>
> 但是页是物理页，页面共享不易实现。

##### 2.2多段方式

> `段`是一个逻辑单位，是进程的一个组成部分，如主程序段，子程序段，数据段。`段`由一个最大长度的限制，但不要求所有的程序的所有`段`的长度都相等。
>
> 在分段机制中，一个进程的地址空间可以包含以下不同的段：`代码段(Code Segment)`、 `数据段(Data Segnet)`、`堆栈段(Stack Segment)`、`内存共享段(Share Memory Segment)`
>
> 一`段`占用一块联系的`存储区`，各`段`占用不连续分区。
>
> * 段表（Segment Table）
>
>   每个进程设置一张段表，用来记录各个段地址映射的关系。
>
>   进程分了几段，段表就有几个表项。一个表项记录一个分段在内存中的`存储地址`和`长度`。
>
> 多段方式的内存仍然按分区管理，会产生`外碎片`
>
> 由于有`外碎片`必然会有响应消除`外碎片`的操作，就会产生程序浮动，也就需要`动态地址重定位`
>
> 段是逻辑段，分段共享很方便。

##### 2.3 段页方式

> 在分段管理的基础上加上分页式管理课形成段页式管理（将分页与分段的优点结合）
>
> 内存划分成大小相等的`页框`
>
> 用户的地址空间被程序员划分成许多段，每个段一次划分成许多固定大小的`页`，`页`的大小等于内存中`页框`的大小
>
> * 位示图
>
>   来记录内存各个帧用与否
>
> * 段表
>
>   系统位一个含有多个分段的进程建立段表，记录各个分段对应段内页表的地址和长度
>
> * 段内页表
>
>   一个分段有一个段内页表，记录该段划分位多少页，每页分配的帧号是多少。



##  虚拟存储管理

####  一、简述

__主存扩充技术：__

> * 覆盖技术：一个程序被分为若干段
>   * 非覆盖段：部分经常要用的基本部分，作为常驻段
>   * 课覆盖段：另一部分不经常使用，可以让他们在需要时临时装入。不同时使用的段可组合成一组可覆盖段。
> * 交换技术
>   * 交换整个作业
>   * 交换整个进程
>   * 交换页面/段面
>
> * 虚拟存储技术 
>   * 离散性
>   * 多次性
>   * 对换性
>   * 虚拟性 

__主存扩充技术的实质：__

目的：将小的实存储器扩充为大的虚拟存储器

实质：将磁盘空间虚拟成内存使用

结果：将进程的一部分装入内存，即可允许

__主存扩充技术的支撑__

程序在执行过程中的一个较短时间内，所执行的指令地址或操作数地址分别局限于一定的存储区域中。

> * 时间局部性：最近访问过的程序代码和数据很快又被访问
> * 空间局部性：某存储单位被使用后，器相邻的存储单元很快被使用

####  二、页面分配算法与分配策略

##### 1.分配算法

* 平均分配法：
* 优先权分配法：
* 比例分配法：

##### 2.分配策略





固定分配策略：

可变分配策略

#### 三、页面置换算法与OPT

##### 1.页面置换策略

* 局部置换策略
* 全局置换策略

##### 2.页面置换算法

* OPT最佳置换：选择以后不再使用的，或者要隔最长时间才能使用的页面予以淘汰。

* FIFO先进先出置换：将驻留在内存中时间最长的页面予以淘汰。（性能不是很好）

* LRU最近最久未用置换： 将内存中上次使用距当前最远的页予以淘汰。（用栈来组装各个驻留页）

  优点缺页率接近OPT，缺点

* Clock页面置换：这是一个建立在循环检测基础上的LRU近似算法，试图以较小的开销获得接近LRU的性能。

