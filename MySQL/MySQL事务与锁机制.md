###  一、数据库事务的四大特性

> ACID  :Atomicity（原子性），Consistent（一致性），Isolation（隔离性），Durable（持久性）。
>
> 原子性，隔离性，持久性，最后都是为了实现一致性。

* __原子性(Atomicity)__

  一个事务是一个最小的执行单元，一个事务内包含的操作，要么都成功，要么都失败。

  原子性在`InnoDB`里面是通过`undo log`来实现的，它记录了数据修改之前的值(逻辑日志)，一旦发送异常，就可以用`undo log`来实现`回滚`操作。

* __一致性(Consistent)__

  指数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。

  例如转账操作，A账户余额减少1000，B账户余额增加500，两个操作都成功，满足了`原子性`，但没有满足`一致性`，因为它导致了会计科目的不平衡。

* __隔离性(Isolation)__

  有了事务的定义以后，在数据库里面会有很多的事务同时去操作同一张表或者同一行数据，必然会产生一些并发或者干扰的操作。

  `隔离性`是指多个事务对表或者行进行并发操作，是透明的，相互之间不干扰的。这样最终也是保证业务数据的`一致性`。

* __持久性(Durable)__

  对数据库的任意操作，只要事务提交成功，那么这一次更改是永久性的。不可能因为系统宕机或者重启了数据库的服务器，它又恢复到原来的状态了。

  `持久性`通过`redo log`和`double write(双写缓冲)`来实现的，我们操作数据的时候，会先学到内存的`buffer pool`里面，同时记录`redo log`，如果在刷盘之前出现异常，在重启后就可以读取`redo log`的内容，写入到磁盘，保证数据的`持久性`。当然，恢复成功的前提是数据也本身没有被破坏，是完整的，这个通过`双写缓冲(double write)`保证。

### 二、什么时候会出现事务

> 无论是我们在 `Navicat` 的这种工具里面去操作，还是在我们的` Java `代码里面通过 `API `去操作，还是加上`@Transactional `的注解或者 `AOP `配置，其实最终都是发送一个`指令`到数据库去执行，`Java` 的 `JDBC` 只不过是把这些命令封装起来了。
>
> 但需要注意的点是，在`MySQL`中，只有`InnoDB`和`NDB`引擎支持事务，其他引擎并不支持事务，如`MyISAM` `MEMORY`等。并且`InnoDB`是目前`MySQL`的默认存储引擎。

##### 1.自动开启事务

当我们在执行一条SQL语句时，它有没有事务呢？

```sql
select * from table1 where id=1;
```

实际上它是自动开启事务，自动提交事务的。因为在`InnoDB引擎`中，如果我们的`SQL`语句没有显示的去开启一个事务，那么它会自动的开启事务，并且自动提交，最终写入磁盘。

当我们执行`SQL`语句，会得到一个结果。

```sql
show variables like 'autocommit'
```

结果中`autocommit`参数的值是`NO`，代表`InnoDB`会自动开启一个事务，并自动提交一个事务。

##### 2.手动开启事务

我们可以将`autocommit`的值设置为`false/off`,那么`InnoDB`就不会自动开启事务，需要我们手动开启与提交。

```sql
set session autocommit = false   //关闭自动事务。但这个更改只影响本次会话，不影响其他会话。
set global autocommit = false    //关闭自动事务。这个更改在全局有效，所有的会话的自动事务都失效。
```

* 开启事务方法

```
begin;                 //方法一
start transaction;     //方法二
```

* 结束事务方法

```
commit;              //方法一，提交一个事务
rollback;            //方法二，回滚
客户端断开连接         //方法三
```

在我们要执行的SQL语句之前开启事务，在SQL语句之后结束事务。

**例：**

```
begin;                                       //开启事务
select * from table1 where id=1;            //要执行的SQL语句
update table1 set name='pygNEW' where id=1;
...
commit;                                    //提交事务
```

###  三、事务并发的三大问题

#####  1.脏读

`事务A`有两次重复的查询操作，`事务B`在这两次查询操作之间修改了数据,**但是没有`COMMIT`**，`事务A`的第二次查询操作读取到了`事务B`没有提交的脏数据。

#####  2.不可重复读

`事务A`有两次重复的查询操作，`事务B`在这两次查询操作之间执行了一个`UPDATE`/`DELETE`操作,**并且执行了`COMMIT`**，导致`事务A`第二次查询时出现了数据不一致。

#####  3.幻读

`事务A`有两次重复查询操作，`事务B`在这两次查询操作之间执行了一个`INSERT`操作,**并且执行了`COMMIT`**，导致`事务A`第二次查询时，出现了新的数据。

###  四、数据库隔离级别

> 事务并发的三大问题本质上都是数据库读一致性问题，必须有数据库提供一定的事务隔离机制来解决。
>
> 所以有一个统一的标准，`SQL92 ANSI/ISO`标准。（这里只是大致提了一下，这些统一标准可能有很多版本）
>
> 然后各个数据库厂商在开发自己的数据库时要去实现这些标准，但是不同厂商对于标准的实现程度的不同的。

##### 1.SQL92定义的四种隔离标准以及解决方案

* **Read Uncommitted(未提交读)** 

  事务未提交的数据对其他事务可见，会出现`脏读`。

* **Read Committed(已提交读)**

  一个事务开始后，只能看到已经提交的事务所做的修改，解决`脏读`问题，会出现`不可重复读`。

* **Repeatable Read(可重复读)**

  在同一个事务种多次读取同样的数据结果是一样的，解决了`不可重复读`，但是没有解决`幻读`问题。

* **Serializable(串行化)**

  最高的隔离级别，通过强制事务的串行化执行，解决所有的事务并发问题，但是效率就很低下了。

  | 事务隔离级别               | 脏读   | 不可重复读 | 幻读   |
  | -------------------------- | ------ | ---------- | ------ |
  | Read Uncommitted(未提交读) | 可能   | 可能       | 可能   |
  | Read Committed(已提交读)   | 不可能 | 可能       | 可能   |
  | Repeatable Read(可重复读)  | 不可能 | 不可能     | 可能   |
  | Serilizable(串行化)        | 不可能 | 不可能     | 不可能 |

##### 2.MySQL中InnoDB的实现的事务隔离级别

> 在MySQL数据库中，只有InnoDB和NDB两个引擎支持事务，而InnoDB是默认的存储引擎。
>
> 并且在InnoDB中`Repeatable Read(可重复读)`是默认的事务隔离级别，同时也可以解决所有的事务并发问题。

| 事务隔离级别               | 脏读   | 不可重复读 | 幻读   |
| -------------------------- | ------ | ---------- | ------ |
| Read Uncommitted(未提交读) | 可能   | 可能       | 可能   |
| Read Committed(已提交读)   | 不可能 | 可能       | 可能   |
| Repeatable Read(可重复读)  | 不可能 | 不可能     | 不可能 |
| Serilizable(串行化)        | 不可能 | 不可能     | 不可能 |

### 五、事务隔离级别的解决方案

> 事务的隔离级别要解决的问题，本质来说就是解决读一致性问题。
>
> 要保证一个事务前后两次读取数据结果一致，有两种解决思路。

##### 1.LBCC

基于锁的并发控制`Lock Based Concurrency Control`

在读取数据前，对其进行加锁，阻止其他事务对数据进行修改。

但是如果仅仅基于锁来实现事务隔离，一个事务读取的时候不允许其他事务修改，那就意味着不支持并发的读写操作，而我们大多数应用都是读多写少，这样会极大地影响操作数据的效率。

##### 2.MVCC 

多版本的并发控制`Multi Version Concurrency Control`

如果要让一个事务前后两次读取的数据保持一致，那么我们可以在修改数据的时候给它建立一个备份或者叫快照，后面再来读取这个快照就行了

[演示模型](https://processon.com/view/5d29999ee4b07917e2e09294)

__PS：__**而为什么有MVCC，在RC级别还是有幻读问题？**

> RC级别，与RR级别建立快照的时间不同。
>
> RC是快照建立时间是在当前`SELECE`语句执行是建立，所以能够看到其他事务已经提交的数据。也就是`幻读`
>
> 而RR级别建立快照是在第一次`SELECT`时，所以未提交的事务，以及其后的事务的操作，是不可见的。

###  四、Innodb的锁

####  1.共享锁（行锁）：Shared Locks

> 读锁（S锁）
>
> 多个事务对于同一个数据可以共享访问，不能操作修改

* 使用方式：

  * 加锁

    ```sql
    SELECT * FROM table WHERE id=1 LOCK IN SHARE MODE
    ```
  
  * 释锁
  * `COMMIT`/`ROLLBACK`

#### 2.排他锁（行锁）：Exclusive Locks

> 写锁（X锁），互斥锁/独占锁
>
> 事务获取了一个数据的X锁，其他事务就不能在获取该行的锁，只有获取了排他锁的事务是可以堆数据进行读取和修改的

* 使用方式：

  * 加锁

    `DELETE`/`UPDATE`/`INSERT`语句会默认加上X锁

    ```sql
    //手动加排他锁
    SELECT * FROM TABLE WHERE...FOR UPDATE
    ```

  * 释锁

    `COMMIT`/`ROLLBACK`

####  3.意向共享锁（表锁）：Intention Shared Locks



#### 4.意向排他锁（表锁）：Intention Exclusive Locks

####  5.临键锁 Next-key Locks

#### 6.间隙锁 Gap Locks

#### 7.记录锁 Record Locks

  



