##  一、什么是synchronized

> 在java多线程的操作过程中，存在一个问题。当多个线程访问同一个资源的时候，由于没有加什么限制，这些不同线程获取的资源是很不安全的。线程`A`可能获取该资源后，线程`B`立即对该资源进行的更改，而线程`A`用的还是更改之前的资源，造成资源不统一。
>
> 而为了解决这样的问题，就提出了一个锁的概念。对某一个共享资源添加一把锁，而这个把锁只有一把钥匙，也就是说，在同一时间，只有一个线程能对该资源进行处理。
>
> 而这个锁，就叫`synchronized`，它是`Java`语言的一个关键字。
>
> `synchronized`加锁、解锁操作是由`JVM`自动自行的，不需要我们手动的添加或者释放锁。但这也带来了一个问题，在加了锁的方法体或者代码块没有执行完毕之前，其他的线程是无法执行的，相对来说效率还是不是很高、也不够灵活，这时候有另外一种锁机制，叫`Lock`它是一个接口，在此处就不去深究Lock，我另外会写文章去研究。

##  二、synchronized的用法

> synchronized有两种用法：`1`是添加在方法上，`2`一种是添加在代码块开头。
>
> 除了添加位置不同，还有作用范围的不同，作用范围也有两个：`1`是对一个对象有效，`2`对一个类有效。
>
>  **例子** ：
> 
> 宝马是一个汽车品牌，这个品牌生成了很多很多的汽车。宝马这个品牌就是一个类，它生成的很多很多汽车就是这个类的实例。

####  1.添加在方法上

> **范围`1`：**宝马品牌的生成的每一辆汽车都有一个独立的锁，并且这个锁只有一把钥匙。同一辆车同一时刻只能有一个人使用。但是不同车之间，是没有任何关联的。
>
> ```java
> //范围1------对一个实例对象有效
> //该方法为非静态方法。
> //这时候这个方法上的锁，的作用范围就为该类的实例对象了。如果该类有其他实例对象，其他实例对象的test()方法与本实例对象的方法是不冲突的。
> public class BMW{
>     public synchronized  void test() {
>     ...
>     }
> }
> ```
>
> 
>
> **范围`2`：**宝马品牌的所有汽车都用一把锁，并且这把锁只有一把钥匙。全球同一时刻，只有一个人，可以使用宝马品牌的车。
>
> ```java
> //范围2------对一个类有效
> //该方法为静态方法。
> //这个锁的作用范围就是对类有效，不管该类创建了多少个对象实例，`test()`方法在同一时间都只能允许一个线程调用。
> public class BMW{
>     public synchronized static void test() {
>     ...
>     }
> }
> ```



####  2.添加在代码块上

> 将synchronized加在代码块上时，需要给一个参数，代表这个锁的范围。这个参数可以是是一个对象，任何对对象。
>
> 这个参数就是一把锁，只要这个参数相同，即使是不同类的不同方法，在同一时间，也只会有一个线程可以执行。也就是说，只要用了同一把锁，在同一时间，都只能有一个线程可以执行。
>
> 
>
> **范围`1`**
>
> **[参数为本对象(this)]：**宝马品牌的生成的每一辆汽车都有一个独立的锁，并且这个锁只有一把钥匙。同一辆车同一时刻只能有一个人使用。但是不同车之间，是没有任何关联的。
>
> ```java
> //this关键字，锁为本对象。
> public class BMW{
>     
>     public void test() {
> //将关键字加载代码块上，此时的参数是 this 表是本对象。这时这个锁的作用范围就是本类的实例对象内有效。
>         synchronized (this) {
>            .....
>         }
>     }
> }
> ```
>
> **[参数为其他实例对象]：**宝马品牌的生成的车当中，其中有一批车的锁是一个第三方厂家提供的，但是这批锁是一样的，并且钥匙也只有一把。所有这一批宝马车，同一时间只有一辆车可以被一个人使用。但这批车与宝马生产的其他车不冲突。
>
> ```java
> public class BMW{
>     
>     privte Object object;
>     
>     public SynchronizedTest(Object object){
>         this.object=object;
>     }
>     
>     public void test() {
> 
>     //此时的参数也是一个对象，但这个对象是其他对象，不是本对象。
>         synchronized (object) {
>            .....
>         }
>     }
> }
> ```
>
> **范围`2`**
>
> **[参数为本类的Class实例]**：`宝马`品牌的所有汽车都用一把锁，并且这把锁只有一把钥匙。全球同一时刻，只有一个人，可以使用`宝马`品牌的车。
>
> ```java
> public class BMW{
>     
>     public void test() {
>        //参数为本类，该类不管有多少个实例对象，该代码块在同一时间都只会有一个线程在执行。
>         synchronized (BMW.class) {
>            .....
>         }
>     }
> }
> ```
>
> **[参数为其他类的Class实例对象]**：`宝马`品牌和`奔驰`品牌下的所有汽车都用一把锁，并且这把锁只有一把钥匙。全球同一时刻，只有一个人，可以使用`宝马`和`奔驰`下的车。
>
> ```java
> //宝马公司
> public class BMW{
>     
>     public void test() {
> //参数为其他类，该BMW类与Benz类不管有多少个实例对象，他们里面加了锁的代码块在同一时间都只会有一个线程在执行。
>         synchronized (Lock.class) {
>            .....
>         }
>     }
> }
> //奔驰gongs
> public class Benz{
>     
>     public void test() {
>  //参数为其他类，该BMW类与Benz类不管有多少个实例对象，他们里面加了锁的代码块在同一时间都只会有一个线程在执行。
>         synchronized (Lock.class) {
>            .....
>         }
>     }
> }
> 
> //一个类，该类代表一个锁厂商
> public class Lock{
>    ....
> }
> 
> ```

##  三、synchronized锁是如何存储的

> 锁的本质是互斥，所有在在JVM中一定会有一个地方去存储关于这个锁的数据，包含这个锁的状态，谁持有锁等。
>
> 而我们知道，在使用`synchronized`时，是必须有一个实例对象的。
>
> 不管是加在方法上还是代码块，都会与对象扯上关系，可以说在使用`synchronized`锁时，这个锁本身就是一个实例对象。
>
> 这个对象可以是我们显示的传递:
>
> ```java
>  synchronized (Lock.class) {
>            .....
>         }
> ```
>
> 也可以是隐式的自己生成：
>
> ```java
>  public synchronized  void test() {
>     ...
>     }
> ```
>
> 而在JVM中，实例对象是存储在堆内存中，而且每个对象有一个对象头，对象头中的`Mark Word`区域正好存储了锁状态标志等信息。

##  四、synchronized锁的优化

> 我们知道，加了锁，对性能的影响很大，毕竟本来很多车道，大家一起跑，现在只能一个一个跑，明显效率低了很多。但是为了安全，牺牲一些效率，也是可以接受的。
>
> 但是`synchronized`为了权衡性能与安全性，提出一个解决方案，`锁升级`。

####  1.偏向锁（性能消耗最小）

当只有一个线程`A`去访问锁，没有其他锁进行竞争的时候，它就不走锁竞争的逻辑，就使用偏向锁。此时偏向锁记录下线程`A`,当下一次在进行访问时，它只需要判断是不是同一个线程。如果是，不走锁竞争的逻辑。

但当有了一个线程`B`去尝试获得锁的时候，它会先撤销掉`A`的偏向锁，然后它尝试去获取。如果成功，就重复`A`的流程。如果失败，就膨胀，锁升级到轻量级锁。

但是发生轻量级锁的情况很少，因为大多数时候，我们设置锁，就是存在安全问题，极大的可能会有线程间的竞争。

####  2.轻量级锁（性能消耗相对小）

当线程`A`获得锁以后，线程`B`并不会立即释放CPU资源，它会`自旋`一定时间，也就是通过循环再尝试去获得锁，这也线程`B`就没有必要阻塞重排了。但是如果获得失败，它总不可能一种占用CPU资源吧，所有它就膨胀，也就是锁升级到重量级锁。这个次数是哟JVM自动执行的，里面的算法我也不知道，以后有时间再研究。

虽然线程`B`进行`自旋`也会消耗CPU资源，但是因为线程`A`占有锁的时间很短，所以使得线程`B`所产生的消耗，相对于上下文切换产生的消耗小得多。

#### 3.重量级锁（性能消耗最高）

当线程`A`获得锁以后，线程`B`需要释放CPU资源，`park`操作让线程挂起。这也的一个操作之后，会有上下文切换，这个是很大的性能损失。

####  4.总结

`synchronized`的为了在减少性能的损耗的同时，也不失去安全性。它会根据具体情况去判断锁的使用。在没有太大必要的时候，减少重量级锁的使用，尽可能采用性能消耗更小的锁方式。



